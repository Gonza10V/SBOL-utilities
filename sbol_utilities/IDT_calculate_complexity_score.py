import os
import requests
import sbol3
from sbol3 import Measure
import tyto
import datetime
import argparse
import logging
import json
from sbol_utilities.workarounds import type_to_standard_extension

IDT_API_TOKEN_URL = "https://www.idtdna.com/Identityserver/connect/token"
IDT_API_SCORE_URL = "https://www.idtdna.com/api/complexities/screengBlockSequences"


def get_token(username: str, password: str, ClientID: str, ClientSecret: str):
    """ Get access token for IDT API

    :param username: Username of your IDT account
    :param password: Password of your IDT account
    :param ClientID: ClientID key of your IDT account
    :param ClientSecret: ClientSecret key of your IDT account
    :return: dictionary with the access token
    """
    data = {'grant_type': 'password', 'username': username, 'password': password, 'scope': 'test'}
    r = requests.post(IDT_API_TOKEN_URL, data, auth=requests.auth.HTTPBasicAuth(ClientID, ClientSecret), timeout = 200)

    if(not('access_token' in r.json())):
        raise Exception("Access token could not be generated. Check your credentials.")
    access_token = r.json()['access_token']
    return access_token

def screening(token, sequences):
    """ Get information of sequences from the IDT API

    :param token: access token generated by get_token
    :param sequences: sequences for which we want to calculate the complexity score
    :return: List of lists of dictionaries with all the information about the sequence's synthesizability features, Number of sequences
    """
    partitions_sequences = [sequences[x:x + 1] for x in range(0, len(sequences), 1)]

    results = []
    for idx, partition in enumerate(partitions_sequences):
        print('Request {0} of {1}'.format(idx+1, len(partitions_sequences)))
        resp = requests.post(IDT_API_SCORE_URL,
                headers={'Authorization': 'Bearer {}'.format(token),
                'Content-Type': 'application/json; charset=utf-8'},
                json=partition,
                timeout=500)
        results.append(resp.json())

    print('Requests to IDT API finished.')
    return results, len(sequences)

def check_synthesizability(username: str, password: str, ClientID: str, ClientSecret: str, doc: sbol3.Document):
    """ Extract complexity scores from IDT API results

    :param username: Username of your IDT account
    :param password: Password of your IDT account
    :param ClientID: ClientID key of your IDT account
    :param ClientSecret: ClientSecret key of your IDT account
    :param doc: SBOL document with sequences of interest in it
    :return: Complexity Scores, Sequence's names, Sequence's elements
    """
    print(f'Importing distribution sequences')

    # Extract sequence identities and elements from SBOL document
    ids = []
    sequence_elements = []
    sequences = []

    for top_level in doc:
        if type(top_level) == sbol3.Sequence:
            ids.append(str(top_level.display_name))
            sequence_elements.append(str(top_level.elements))
            seq = {"Name": str(top_level.display_name), "Sequence": str(top_level.elements)}
            sequences.append(seq)

    print(f'Connecting to IDT DNA')
    token = get_token(username, password, ClientID, ClientSecret)
    scores, length_sequences = screening(token, sequences)
    #print(json.dumps(scores, indent=4, separators=(". ", " = ")))

    #Retrieve only complexity scores
    scores_list = []
    cont = 0

    for i in range(0, length_sequences):
        cont += 1
        complexity_score = 0
        for k in range(0, len(scores[i][0])):
            pivot = scores[i][0]
            complexity_score += pivot[k].get('Score')
        scores_list.append(complexity_score)

    #print(scores_list)

    return scores_list, ids, sequence_elements

def IDT_calculate_complexity_score(username: str, password: str, ClientID: str, ClientSecret: str, doc: sbol3.Document):
    """ Add computed complexity scores of sequences to SBOL document with a timestamp

    :param username: Username of your IDT account
    :param password: Password of your IDT account
    :param ClientID: ClientID key of your IDT account
    :param ClientSecret: ClientSecret key of your IDT account
    :param doc: SBOL document with sequences of interest in it
    :return: List of dictionaries of sequences and their complexities scores
    """
    DateTime = datetime.datetime.utcnow()
    sbol3.set_namespace('http://sbolstandard.org/testfiles')
    #Define unit measure as dimensionless
    number_unit = tyto.OM.number_unit
    #Create an Activity object to store timestamp
    sequence_timestamp = sbol3.Activity('Timestamp', end_time=DateTime.isoformat(timespec='seconds') + 'Z')
    doc.add(sequence_timestamp)

    scores_list, ids, sequence_elements = check_synthesizability(username, password, ClientID, ClientSecret, doc)

    results = []
    i = 0
    for sequ in doc:
        if type(sequ) == sbol3.Sequence:
            measure = Measure(scores_list[i], unit=number_unit, name='Measure_'+ids[i], types = [tyto.EDAM.sequence_complexity_report])
            measure.generated_by = [sequence_timestamp]
            sequ.measures.append(measure)
            results.append({"Sequence Name": ids[i], "Complexity Score": scores_list[i]})
            i = i + 1
    return results

def main():
    """
    Main wrapper: read from input file, invoke IDT_calculate_complexity_score, then write to output file
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('username', help="Username of your IDT account")
    parser.add_argument('password', help="Password of your IDT account")
    parser.add_argument('ClientID', help="ClientID of your IDT account")
    parser.add_argument('ClientSecret', help="ClientSecret of your IDT account")
    parser.add_argument('sbol_file', help="Absolute path to sbol file with sequences")
    parser.add_argument('output_name', help="Name of SBOL file to be written")
    parser.add_argument('-t', '--file-type', dest='file_type', default=sbol3.SORTED_NTRIPLES,
                        help="Name of SBOL file to output to (excluding type)")

    parser.add_argument('--verbose', '-v', dest='verbose', action='count', default=0)
    args_dict = vars(parser.parse_args())

    # Extract arguments:
    verbosity = args_dict['verbose']
    username = args_dict['username']
    password = args_dict['password']
    ClientID = args_dict['ClientID']
    ClientSecret = args_dict['ClientSecret']
    sbol_file = args_dict['sbol_file']
    output_name = args_dict['output_name']

    file_type = args_dict['file_type']
    extension = type_to_standard_extension[file_type]
    outfile_name = output_name if output_name.endswith(extension) else output_name + extension

    doc = sbol3.Document()
    doc.read(sbol_file)
    results = IDT_calculate_complexity_score(username, password, ClientID, ClientSecret, doc)
    doc.write(outfile_name, file_type)


if __name__ == '__main__':
    main()
