import requests
import sbol3
import tyto
import datetime
import argparse
import logging
import uuid
from sbol_utilities.workarounds import type_to_standard_extension

IDT_API_TOKEN_URL = "https://www.idtdna.com/Identityserver/connect/token"
IDT_API_SCORE_URL = "https://www.idtdna.com/api/complexities/screengBlockSequences"
SCORE_TIMEOUT = 500
"""Time to wait for score query requests to complete"""


def get_token(username: str, password: str, ClientID: str, ClientSecret: str) -> str:
    """ Get access token for IDT API

    :param username: Username of your IDT account
    :param password: Password of your IDT account
    :param ClientID: ClientID key of your IDT account
    :param ClientSecret: ClientSecret key of your IDT account
    :return: dictionary with the access token
    """

    data = {'grant_type': 'password', 'username': username, 'password': password, 'scope': 'test'}
    r = requests.post(IDT_API_TOKEN_URL, data, auth=requests.auth.HTTPBasicAuth(ClientID, ClientSecret), timeout=SCORE_TIMEOUT)

    if(not('access_token' in r.json())):
        raise Exception("Access token could not be generated. Check your credentials.")
    access_token = r.json()['access_token']
    return access_token


def screening(token, sequences) -> [list,int]:
    """Retrieve synthesis complexity scores of sequences from the IDT API

    :param token: access token generated by get_token
    :param sequences: sequences for which we want to calculate the complexity score
    :return: List of lists of dictionaries with all the information about the sequence's synthesizability features, Number of sequences
    """
    partitions_sequences = [sequences[x:x + 1] for x in range(0, len(sequences), 1)]

    results = []
    for idx, partition in enumerate(partitions_sequences):
        logging.debug('Request {0} of {1}'.format(idx+1, len(partitions_sequences)))
        resp = requests.post(IDT_API_SCORE_URL,
                headers={'Authorization': 'Bearer {}'.format(token),
                'Content-Type': 'application/json; charset=utf-8'},
                json=partition,
                timeout=SCORE_TIMEOUT)
        results.append(resp.json())

    logging.info('Requests to IDT API finished.')
    return results, len(sequences)


def check_synthesizability(username: str, password: str, ClientID: str, ClientSecret: str, doc: sbol3.Document) -> [list[float], list[str],list[str]]:
    """ Extract complexity scores from IDT API results

    :param username: Username of your IDT account
    :param password: Password of your IDT account
    :param ClientID: ClientID key of your IDT account
    :param ClientSecret: ClientSecret key of your IDT account
    :param doc: SBOL document with sequences of interest in it
    :return: Complexity Scores, Sequence's names, Sequence's elements
    """
    logging.info(f'Importing distribution sequences')

    # Extract sequence identities and elements from SBOL document
    ids = []
    sequence_elements = []
    sequences = []

    for top_level in doc:
        if type(top_level) == sbol3.Sequence:
            ids.append(str(top_level.display_name))
            sequence_elements.append(str(top_level.elements))
            seq = {"Name": str(top_level.display_name), "Sequence": str(top_level.elements)}
            sequences.append(seq)

    logging.info(f'Connecting to IDT DNA')
    token = get_token(username, password, ClientID, ClientSecret)
    scores, length_sequences = screening(token, sequences)

    #Retrieve only complexity scores
    scores_list = []
    cont = 0

    for i in range(0, length_sequences):
        cont += 1
        complexity_score = 0
        for k in range(0, len(scores[i][0])):
            pivot = scores[i][0]
            complexity_score += pivot[k].get('Score')
        scores_list.append(complexity_score)

    return scores_list, ids, sequence_elements

def IDT_calculate_complexity_score(username: str, password: str, ClientID: str, ClientSecret: str, doc: sbol3.Document) -> list[dict]:
    """ Add computed complexity scores of sequences to SBOL document with a timestamp

    :param username: Username of your IDT account
    :param password: Password of your IDT account
    :param ClientID: ClientID key of your IDT account
    :param ClientSecret: ClientSecret key of your IDT account
    :param doc: SBOL document with sequences of interest in it
    :return: List of dictionaries of sequences and their complexities scores
    """

    sbol3.set_namespace('http://igem.org/IDT_complexity_score')
    #Define unit measure as dimensionless
    number_unit = tyto.OM.number_unit
    #Add Report Generation
    REPORT_ACTIVITY_TYPE = 'https://github.com/SynBioDex/SBOL-utilities/compute-sequence-complexity'
    date_time = datetime.datetime.utcnow()
    timestamp = date_time.isoformat(timespec='seconds') + 'Z'
    report_unique_id = f'Complexity_Report_{timestamp.replace(":", "").replace("-", "")}_{str(uuid.uuid4())[0:8]}'
    report_generation = sbol3.Activity(report_unique_id, end_time=timestamp, types=[REPORT_ACTIVITY_TYPE])
    doc.add(report_generation)

    scores_list, ids, sequence_elements = check_synthesizability(username, password, ClientID, ClientSecret, doc)

    results = []
    i = 0
    for sequ in doc:
        if type(sequ) == sbol3.Sequence:
            measure = sbol3.Measure(scores_list[i], unit=number_unit, name='Measure_'+ids[i], types = [tyto.EDAM.sequence_complexity_report])
            measure.generated_by = [report_generation]
            sequ.measures.append(measure)
            results.append({"Sequence Name": ids[i], "Complexity Score": scores_list[i]})
            i = i + 1

    return results


def main():
    """
    Main wrapper: read from input file, invoke IDT_calculate_complexity_score, then write to output file
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('username', help="Username of your IDT account")
    parser.add_argument('password', help="Password of your IDT account")
    parser.add_argument('ClientID', help="ClientID of your IDT account")
    parser.add_argument('ClientSecret', help="ClientSecret of your IDT account")
    parser.add_argument('input_file', help="Absolute path to sbol file with sequences")
    parser.add_argument('output_name', help="Name of SBOL file to be written")
    parser.add_argument('-t', '--file-type', dest='file_type', default=sbol3.SORTED_NTRIPLES,
                        help="Name of SBOL file to output to (excluding type)")
    parser.add_argument('--verbose', '-v', dest='verbose', action='count', default=0)
    args_dict = vars(parser.parse_args())

    # Extract arguments:
    verbosity = args_dict['verbose']
    input_file = args_dict['input_file']
    output_name = args_dict['output_name']

    extension = type_to_standard_extension[args_dict['file_type']]
    outfile_name = output_name if output_name.endswith(extension) else output_name + extension

    # Read file, convert, and write resulting document
    logging.info('Reading SBOL file ' + input_file)
    doc = sbol3.Document()
    doc.read(input_file)
    results = IDT_calculate_complexity_score(args_dict['username'], args_dict['password'], args_dict['ClientID'], args_dict['ClientSecret'], doc)
    doc.write(outfile_name, args_dict['file_type'])
    logging.info('SBOL file written to %s with %i new scores calculated', outfile_name, len(results))

if __name__ == '__main__':
    main()
