from __future__ import annotations

import datetime
import argparse
import logging
import uuid
from requests import post
from requests.auth import HTTPBasicAuth

import sbol3
import tyto
from sbol_utilities.workarounds import type_to_standard_extension

IDT_API_TOKEN_URL = "https://www.idtdna.com/Identityserver/connect/token"
IDT_API_SCORE_URL = "https://www.idtdna.com/api/complexities/screengBlockSequences"
SEQUENCE_BLOCK_SIZE = 1  # TODO: determine if it is possible to run multiple sequences in a block
SCORE_TIMEOUT = 120
"""Number of seconds to wait for score query requests to complete"""


def get_idt_access_token(username: str, password: str, client_id: str, client_secret: str) -> str:
    """Get access token for IDT API (see: https://www.idtdna.com/pages/tools/apidoc)

    :param username: Username of your IDT account
    :param password: Password of your IDT account
    :param client_id: ClientID key of your IDT account
    :param client_secret: ClientSecret key of your IDT account
    :return: dictionary with the access token
    """
    logging.info(f'Connecting to IDT DNA')
    data = {'grant_type': 'password', 'username': username, 'password': password, 'scope': 'test'}
    result = post(IDT_API_TOKEN_URL, data, auth=HTTPBasicAuth(client_id, client_secret), timeout=SCORE_TIMEOUT)

    if 'access_token' in result.json():
        return result.json()['access_token']
    else:
        raise Exception("Access token for IDT API could not be generated. Check your credentials.")


def get_idt_sequence_scores(token, sequences) -> list:
    """Retrieve synthesis complexity scores of sequences from the IDT API
    This system uses the gBlock API, which is intended for sequences from 125 to 3000 bp in length

    :param token: access token generated by get_idt_access_token
    :param sequences: sequences for which we want to calculate the complexity score
    :return: List of lists of dictionaries with information about sequence synthesizability features
    """
    partitions_sequences = [sequences[x:x + 1] for x in range(0, len(sequences), SEQUENCE_BLOCK_SIZE)]
    results = []
    for idx, partition in enumerate(partitions_sequences):
        logging.debug('Sequence score request %i of %i', idx+1, len(partitions_sequences))
        resp = post(IDT_API_SCORE_URL, json=partition, timeout=SCORE_TIMEOUT,
                    headers={'Authorization': 'Bearer {}'.format(token),
                             'Content-Type': 'application/json; charset=utf-8'})
        results.append(resp.json())
    logging.info('Requests to IDT API finished.')
    return results


def check_synthesizability(username: str, password: str, client_id: str, client_secret: str, doc: sbol3.Document) \
        -> [list[float], list[str], list[str]]:
    """ Extract complexity scores from IDT API results

    :param username: Username of your IDT account
    :param password: Password of your IDT account
    :param client_id: ClientID key of your IDT account
    :param client_secret: ClientSecret key of your IDT account
    :param doc: SBOL document with sequences of interest in it
    :return: Complexity Scores, Sequence names, Sequence elements
    """
    # Extract sequence identities and elements from SBOL document
    logging.info(f'Importing distribution sequences')
    ids = []
    sequences = []

    for top_level in doc:
        if type(top_level) == sbol3.Sequence:
            ids.append(str(top_level.display_name))
            seq = {"Name": str(top_level.display_name), "Sequence": str(top_level.elements)}
            sequences.append(seq)

    token = get_idt_access_token(username, password, client_id, client_secret)
    scores = get_idt_sequence_scores(token, sequences)

    # Compute total score for each sequence as the sum all complexity scores
    scores_list = []
    for score_set in scores:
        complexity_score = 0
        for k in range(0, len(score_set[0])):
            pivot = score_set[0]
            complexity_score += pivot[k].get('Score')
        scores_list.append(complexity_score)

    return scores_list, ids

def IDT_calculate_complexity_score(username: str, password: str, ClientID: str, ClientSecret: str, doc: sbol3.Document) -> list[dict]:
    """ Add computed complexity scores of sequences to SBOL document with a timestamp

    :param username: Username of your IDT account
    :param password: Password of your IDT account
    :param ClientID: ClientID key of your IDT account
    :param ClientSecret: ClientSecret key of your IDT account
    :param doc: SBOL document with sequences of interest in it
    :return: List of dictionaries of sequences and their complexities scores
    """

    sbol3.set_namespace('http://igem.org/IDT_complexity_score')
    #Define unit measure as dimensionless
    number_unit = tyto.OM.number_unit
    #Add Report Generation
    REPORT_ACTIVITY_TYPE = 'https://github.com/SynBioDex/SBOL-utilities/compute-sequence-complexity'
    date_time = datetime.datetime.utcnow()
    timestamp = date_time.isoformat(timespec='seconds') + 'Z'
    report_unique_id = f'Complexity_Report_{timestamp.replace(":", "").replace("-", "")}_{str(uuid.uuid4())[0:8]}'
    report_generation = sbol3.Activity(report_unique_id, end_time=timestamp, types=[REPORT_ACTIVITY_TYPE])
    doc.add(report_generation)

    scores_list, ids = check_synthesizability(username, password, ClientID, ClientSecret, doc)

    results = []
    i = 0
    for sequ in doc:
        if type(sequ) == sbol3.Sequence:
            measure = sbol3.Measure(scores_list[i], unit=number_unit, name='Measure_'+ids[i], types = [tyto.EDAM.sequence_complexity_report])
            measure.generated_by = [report_generation]
            sequ.measures.append(measure)
            results.append({"Sequence Name": ids[i], "Complexity Score": scores_list[i]})
            i = i + 1

    return results


def main():
    """
    Main wrapper: read from input file, invoke IDT_calculate_complexity_score, then write to output file
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('username', help="Username of your IDT account")
    parser.add_argument('password', help="Password of your IDT account")
    parser.add_argument('ClientID', help="ClientID of your IDT account")
    parser.add_argument('ClientSecret', help="ClientSecret of your IDT account")
    parser.add_argument('input_file', help="Absolute path to sbol file with sequences")
    parser.add_argument('output_name', help="Name of SBOL file to be written")
    parser.add_argument('-t', '--file-type', dest='file_type', default=sbol3.SORTED_NTRIPLES,
                        help="Name of SBOL file to output to (excluding type)")
    parser.add_argument('--verbose', '-v', dest='verbose', action='count', default=0)
    args_dict = vars(parser.parse_args())

    # Extract arguments:
    verbosity = args_dict['verbose']
    input_file = args_dict['input_file']
    output_name = args_dict['output_name']

    extension = type_to_standard_extension[args_dict['file_type']]
    outfile_name = output_name if output_name.endswith(extension) else output_name + extension

    # Read file, convert, and write resulting document
    logging.info('Reading SBOL file ' + input_file)
    doc = sbol3.Document()
    doc.read(input_file)
    results = IDT_calculate_complexity_score(args_dict['username'], args_dict['password'], args_dict['ClientID'], args_dict['ClientSecret'], doc)
    doc.write(outfile_name, args_dict['file_type'])
    logging.info('SBOL file written to %s with %i new scores calculated', outfile_name, len(results))

if __name__ == '__main__':
    main()
